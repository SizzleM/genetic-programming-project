package gp;

import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashMap;
import java.util.Iterator;

import javax.swing.JOptionPane;

import org.apache.log4j.Logger;
import org.jfree.chart.JFreeChart;

import com.graphbuilder.math.Expression;
import com.graphbuilder.math.ExpressionTree;
import com.graphbuilder.math.VarMap;

/**
 * This class represents a thread that finds the equation using genetic
 * programming
 * 
 * @author Trevor Greene
 * @version 1.0
 */
public class FindThread extends Thread {
	public static final String DATE_FORMAT = "mm:ss";
	static Logger logger = Logger.getLogger(GeneticProgramming.class);

	public static TreeFitnessComparator getTreeComparator() {
		return FindThread.treeComparator;
	}

	public static void sortTrees(ArrayList<Tree> newTrees) {
		Collections.sort(newTrees, getTreeComparator());
	}

	private javax.swing.JLabel bestResultValueLabel;
	private double crossoverRate;
	private EquationGraphPanel equationGraphPanel = null;
	private javax.swing.JLabel finalEquationResultLabel;
	private javax.swing.JLabel finalGenerationResultLabel;
	private javax.swing.JLabel finalTimeresultLabel;
	private javax.swing.JLabel fitnessValueLabel;
	private javax.swing.JFrame frame;
	private FunctionalSet functionalSet = new FunctionalSet();
	private int generation = 0;
	private javax.swing.JLabel generationValueLabel;
	private boolean gui = false;
	private int hieghtOfTree;
	private double lowestFitness = 1.79769E+308;
	private int maxHeight;
	private int maxRange;
	private int minRange;
	private double mutationRate;
	private int numberOfTrees;
	private ArrayList<Tree> population = null;
	private PopulationFitnessPanel populationFitnessPanel;
	private javax.swing.JDialog resultDialog;
	private javax.swing.JLabel runtimeValueLabel;
	private SimpleDateFormat sdf = new SimpleDateFormat(DATE_FORMAT);
	private long startTime = 0;
	private String targetExpersion = new String();
	private TerminalSet terminalSet = new TerminalSet();
	private static TreeFitnessComparator treeComparator = new TreeFitnessComparator();
	private javax.swing.JTree treeView;

	private double[] calculateTargetValues(String targetedExpresion,
			int[] dataset) {
		int datasetSize = dataset.length;
		double[] targetTreeValues = new double[datasetSize];
		for (int x = 0; x < datasetSize; x++) {
			Expression exp = ExpressionTree.parse(targetedExpresion);
			VarMap vm = new VarMap(false /* case sensitive */);
			vm.setValue("x", dataset[x]);
			targetTreeValues[x] = exp.eval(vm, null);
		}
		return targetTreeValues;
	}

	private ArrayList<Tree> cull(ArrayList<Tree> newTrees) throws Exception {
		logger.debug("Max Number of Trees: " + getNumberOfTrees());
		logger.debug("Original pop size: " + newTrees.size());
		for (int x = getNumberOfTrees(); getNumberOfTrees() < newTrees.size(); x++) {
			logger.debug(" pop size  = " + newTrees.size());
			newTrees.remove(getNumberOfTrees());
		}
		return newTrees;
	}

	/**
	 * Method for populating a tree with nodes.
	 * 
	 * @param tree
	 *            - Tree that needs nodes generated
	 * @param parent
	 *            - Parent node to attach sibling (leaf) nodes onto.
	 * @param level
	 *            - The level the nodes are being applied to.
	 * @param height
	 *            - The height of the tree when finished
	 */
	private void generateNodes(Tree newTree, Node newParent, int howDeepToMakeIt) {
		try {
			if (newParent.getLevel() == howDeepToMakeIt - 1) {
				Node lOperand = new Node(newParent, getTerminalSet()
						.randomOperand(), Node.LEFT, Node.OPERAND);
				newTree.addNode(lOperand);
				Node rOperand = new Node(newParent, getTerminalSet()
						.randomOperand(), Node.RIGHT, Node.OPERAND);
				newTree.addNode(rOperand);
			} else {
				Node lOperator = new Node(newParent, getFunctionalSet()
						.randomOperator(), Node.LEFT, Node.OPERATOR);
				newTree.addNode(lOperator);
				generateNodes(newTree, lOperator, howDeepToMakeIt);
				Node rOperator = new Node(newParent, getFunctionalSet()
						.randomOperator(), Node.RIGHT, Node.OPERATOR);
				newTree.addNode(rOperator);
				generateNodes(newTree, rOperator, howDeepToMakeIt);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	/**
	 * This method generates a set of values that are generated by the passed in
	 * equation.
	 * 
	 * @param min
	 *            - Minimum integer range
	 * @param max
	 *            - Maximum integer range
	 * @return - ArrayList of integers in range specified.
	 */
	private int[] genertateTrainingDataSet(int newMin, int newMax) {
		int[] values = new int[newMax - newMin];
		for (int x = 0; x < values.length; x++) {
			values[x] = newMin++;
		}
		return values;
	}

	/**
	 * This method gives the thread access to the best Best Result Value Label
	 * in the GUI
	 * 
	 * @return - bestResultValueLabel
	 */
	private javax.swing.JLabel getBestResultValueLabel() {
		return this.bestResultValueLabel;
	}

	/**
	 * This method gives the thread access to the crossover rate in the GUI
	 * 
	 * @return - double - crossover rate
	 */
	private double getCrossoverRate() {
		return this.crossoverRate;
	}

	/**
	 * This method gives the thread access to the equation graph panel in the
	 * GUI
	 * 
	 * @return - Equation Graph Panel
	 */
	private EquationGraphPanel getEquationGraphPanel() {
		return this.equationGraphPanel;
	}

	/**
	 * This method gives the thread access to the final equation result label in
	 * the GUI
	 * 
	 * @return - final Equation Result Label
	 */
	private javax.swing.JLabel getFinalEquationResultLabel() {
		return this.finalEquationResultLabel;
	}

	/**
	 * This method gives the thread access to the final generation result label
	 * in the GUI
	 * 
	 * @return - final generation result label
	 */
	private javax.swing.JLabel getFinalGenerationResultLabel() {
		return this.finalGenerationResultLabel;
	}

	/**
	 * This method gives the thread access to the final time result label in the
	 * GUI
	 * 
	 * @return - final generation time label
	 */
	private javax.swing.JLabel getFinalTimeresultLabel() {
		return this.finalTimeresultLabel;
	}

	/**
	 * This method gives the thread access to the fitness value label in the GUI
	 * 
	 * @return - Fitness value label
	 */
	private javax.swing.JLabel getFitnessValueLabel() {
		return this.fitnessValueLabel;
	}

	/**
	 * This method gives the thread access to the GUI JFrame
	 * 
	 * @return - GUI JFrame
	 */
	private javax.swing.JFrame getFrame() {
		return this.frame;
	}

	/**
	 * This method gives the thread access to the functional set
	 * 
	 * @return - FunctionalSet
	 */
	private FunctionalSet getFunctionalSet() {
		return this.functionalSet;
	}

	// private int getGeneration() {
	// return generation;
	// }
	/**
	 * This method gives the thread access to the Generation Value Label
	 * 
	 * @return - GenerationValueLabel
	 */
	private javax.swing.JLabel getGenerationValueLabel() {
		return this.generationValueLabel;
	}

	/**
	 * This method gives the thread access to the tree height setting
	 * 
	 * @return - int - tree height
	 */
	private int getHieghtOfTree() {
		return this.hieghtOfTree;
	}

	// private double getLowestFitness() {
	// return lowestFitness;
	// }
	/**
	 * This method gives the thread access to the tree max height setting
	 * 
	 * @return - int - tree height
	 */
	private int getMaxHeight() {
		return this.maxHeight;
	}

	/**
	 * This method gives the thread access to the training data's max size
	 * 
	 * @return - int - max training size
	 */
	private int getMaxRange() {
		return this.maxRange;
	}

	/**
	 * This method gives the thread access to the training data's min size
	 * 
	 * @return - int - min training size
	 */
	private int getMinRange() {
		return this.minRange;
	}

	/**
	 * This method gives the thread access to the mutation rate in the GUI
	 * 
	 * @return - double - mutation rate
	 */
	private double getMutationRate() {
		return this.mutationRate;
	}

	/**
	 * This method gives the thread access to the max size of population
	 * 
	 * @return - int - number Of Trees
	 */
	private int getNumberOfTrees() {
		return this.numberOfTrees;
	}

	/**
	 * This method gives the thread access to the Population Fitness Panel
	 * 
	 * @return - PopulationFitnessPanel
	 */
	private PopulationFitnessPanel getPopulationFitnessPanel() {
		return this.populationFitnessPanel;
	}

	/**
	 * This method gives the thread access to the result Dialog
	 * 
	 * @return JDialog resultDialog
	 */
	private javax.swing.JDialog getResultDialog() {
		return this.resultDialog;
	}

	/**
	 * This method gives the thread access to the Runtime Value Label
	 * 
	 * @return JLabel Runtime Value Label
	 */
	private javax.swing.JLabel getRuntimeValueLabel() {
		return this.runtimeValueLabel;
	}

	/**
	 * This method gives the thread access to the target expression
	 * 
	 * @return String - target Expression
	 */
	private String getTargetExpersion() {
		return this.targetExpersion;
	}

	/**
	 * 
	 * @return TerminalSet
	 */
	private TerminalSet getTerminalSet() {
		return this.terminalSet;
	}

	public javax.swing.JTree getTreeView() {
		return this.treeView;
	}

	public void getUniqueValues(ArrayList<Tree> newTrees) {
		try {
			HashMap<String, Tree> map = new HashMap<String, Tree>();
			for (int t = 0; t < newTrees.size() - 1; t++) {
				String id = newTrees.get(t).toString();
				map.put(id, newTrees.get(t));
			}
			newTrees.clear();
			Iterator<Tree> values = map.values().iterator();
			while (values.hasNext()) {
				newTrees.add(values.next());
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public boolean isGui() {
		return this.gui;
	}

	private void keepLooking(ArrayList<Tree> newTrees, double newCrossoverRate,
			double newMutationRate, int[] newDataset,
			double[] newTargetTreeValues, int newMaxHeight) throws Exception {
		if ((System.currentTimeMillis() - startTime) > 900000) {
			if (isGui()) {
				JOptionPane.showMessageDialog(getFrame(),
						"This run has taken longer then 15 minutes!!", "Error",
						JOptionPane.ERROR_MESSAGE);
			}
			throw new Exception("This run has taken longer then 15 minutes!!");
		} else {
			try {
				logger.debug("Generation: " + generation++);
				if (isGui()) {
					this.getGenerationValueLabel().setText(generation + "");
				}
				logger.debug("Number of Trees: " + newTrees.size());
				Mutation.mutateTrees(newTrees, newMutationRate, newDataset,
						newTargetTreeValues);
				sortTrees(newTrees);
				if (isGui()) {
					this.getRuntimeValueLabel().setText(
							sdf.format(System.currentTimeMillis() - startTime));
				}
				Crossover.cross(newTrees, newCrossoverRate, newMaxHeight,
						newDataset, newTargetTreeValues);
				sortTrees(newTrees);
				if (isGui()) {
					this.getRuntimeValueLabel().setText(
							sdf.format(System.currentTimeMillis() - startTime));
				}
				// getUniqueValues(newTrees);
				newTrees = cull(newTrees);
				int numberOfTrees = newTrees.size();
				for (int x = 0; x < numberOfTrees; x++) {
					Tree tr = newTrees.get(x);

					if (tr.getFitness() < lowestFitness) {
						lowestFitness = tr.getFitness();
						if (isGui()) {
							this.getBestResultValueLabel().setText(
									tr.toString());
							this.getFitnessValueLabel().setText(
									tr.getFitness() + "");
							if (getEquationGraphPanel().isVisible()) {
								updateEquationChart(tr, equationGraphPanel);
							}
						}
					}
					if (tr.getFitness() == 0) {
						logger.info("found tree");
						logger.info("Generation: " + generation);
						logger.info("Equation: " + tr.toString());
						logger.info("Time: "
								+ sdf.format(System.currentTimeMillis()
										- startTime));
						if (isGui()) {
							getFinalTimeresultLabel().setText(
									sdf.format(System.currentTimeMillis()
											- startTime));
							updateEquationChart(tr, equationGraphPanel);
							updateFitnessChart(newDataset, newTargetTreeValues,
									newTrees, getPopulationFitnessPanel());

							getBestResultValueLabel().setText(tr.toString());
							getFitnessValueLabel()
									.setText(tr.getFitness() + "");
							getFinalEquationResultLabel()
									.setText(tr.toString());
							getFinalGenerationResultLabel().setText(
									generation + "");

							getResultDialog().pack();
							getResultDialog().setVisible(true);
						}
						return;
					}

				}
				if (isGui()) {
					this.getRuntimeValueLabel().setText(
							sdf.format(System.currentTimeMillis() - startTime));
				}
				if (isGui() && getPopulationFitnessPanel().isVisible()) {
					updateFitnessChart(newDataset, newTargetTreeValues,
							newTrees, getPopulationFitnessPanel());
				}
				keepLooking(newTrees, newCrossoverRate, newMutationRate,
						newDataset, newTargetTreeValues, newMaxHeight);

			} catch (Exception e) {
				e.printStackTrace();

			}
		}
	}

	/*
	 * This method creates a random population of trees using the terminal and
	 * functional sets
	 * 
	 * @param numberOfTrees - Size of binary tree population.
	 * 
	 * @param height - height of binary tree
	 * 
	 * @return - Returns a ArrayList of binary trees
	 */
	private ArrayList<Tree> populate(int newNumberOfTrees, int newHeight,
			int[] newDataset, double[] newTargetTreeValues) {
		this.population = new ArrayList<Tree>();
		try {
			for (int tree = 0; tree < newNumberOfTrees; tree++) {
				Node rootNode = new Node(null, this.getFunctionalSet()
						.randomOperator(), null, Node.OPERATOR);
				Tree bt = new Tree(rootNode, this.getTerminalSet(), this
						.getFunctionalSet());
				rootNode.setTree(bt);
				generateNodes(bt, rootNode, newHeight);

				double fitness = Fitness.checkFitness(newTargetTreeValues,
						Fitness.calculateExpressionValues(bt, newDataset));
				bt.setFitness(fitness);
				this.population.add(bt);
			}
		} catch (Exception e) {
			e.printStackTrace();
		}
		return population;
	}

	@Override
	public void run() {
		try {
			startTime = System.currentTimeMillis();
			int[] dataset = genertateTrainingDataSet(this.getMinRange(), this
					.getMaxRange());
			double[] targetValues = calculateTargetValues(getTargetExpersion()
					.toString(), dataset);
			ArrayList<Tree> populationTree = populate(this.getNumberOfTrees(),
					this.getHieghtOfTree(), dataset, targetValues);
			keepLooking(populationTree, this.getCrossoverRate(), this
					.getMutationRate(), dataset, targetValues, this
					.getMaxHeight());
		} catch (Exception e) {
			e.printStackTrace();
		}
	}

	public void setBestResultValueLabel(
			javax.swing.JLabel newBestResultValueLabel) {
		this.bestResultValueLabel = newBestResultValueLabel;

	}

	public void setCrossoverRate(double newCrossoverRate) {
		this.crossoverRate = newCrossoverRate;

	}

	public void setEquationGraphPanel(EquationGraphPanel newEquationGraphPanel) {
		this.equationGraphPanel = newEquationGraphPanel;
	}

	public void setFinalEquationResultLabel(
			javax.swing.JLabel newFinalEquationResultLabel) {
		this.finalEquationResultLabel = newFinalEquationResultLabel;
	}

	public void setFinalGenerationResultLabel(
			javax.swing.JLabel newFinalGenerationResultLabel) {
		this.finalGenerationResultLabel = newFinalGenerationResultLabel;
	}

	public void setFinalTimeresultLabel(
			javax.swing.JLabel newFinalTimeresultLabel) {
		this.finalTimeresultLabel = newFinalTimeresultLabel;
	}

	public void setFitnessValueLabel(javax.swing.JLabel newFitnessValueLabel) {
		this.fitnessValueLabel = newFitnessValueLabel;
	}

	public void setFrame(javax.swing.JFrame newFrame) {
		this.frame = newFrame;
	}

	public void setFunctionalSet(FunctionalSet newFunctionalSet) {
		this.functionalSet = newFunctionalSet;
	}

	public void setGeneration(int newGeneration) {
		this.generation = newGeneration;
	}

	public void setGenerationValueLabel(
			javax.swing.JLabel newGenerationValueLabel) {
		this.generationValueLabel = newGenerationValueLabel;
	}

	public void setGui(boolean newGui) {
		this.gui = newGui;
	}

	public void setHieghtOfTree(int newHieghtOfTree) {
		this.hieghtOfTree = newHieghtOfTree;
	}

	public void setLowestFitness(double newLowestFitness) {
		this.lowestFitness = newLowestFitness;
	}

	public void setMaxHeight(int newMaxHeight) {
		this.maxHeight = newMaxHeight;
	}

	public void setMaxRange(int newMaxRange) {
		this.maxRange = newMaxRange;
	}

	public void setMinRange(int newMinRange) {
		this.minRange = newMinRange;
	}

	public void setMutationRate(double newMutationRate) {
		this.mutationRate = newMutationRate;
	}

	public void setNumberOfTrees(int newNumberOfTrees) {
		this.numberOfTrees = newNumberOfTrees;
	}

	public void setPopulation(ArrayList<Tree> newPopulation) {
		this.population = newPopulation;
	}

	public void setPopulationFitnessPanel(
			PopulationFitnessPanel newPopulationFitnessPanel) {
		this.populationFitnessPanel = newPopulationFitnessPanel;
	}

	public void setResultDialog(javax.swing.JDialog newResultDialog) {
		this.resultDialog = newResultDialog;
	}

	public void setRuntimeValueLabel(javax.swing.JLabel newRuntimeValueLabel) {
		this.runtimeValueLabel = newRuntimeValueLabel;
	}

	public void setStartTime(long newStartTime) {
		this.startTime = newStartTime;
	}

	public void setTargetExpersion(String newTargetExpersion) {
		this.targetExpersion = newTargetExpersion;
	}

	public void setTerminalSet(TerminalSet newTerminalSet) {
		this.terminalSet = newTerminalSet;
	}

	public void setTreeComparator(TreeFitnessComparator newTreeComparator) {
		FindThread.treeComparator = newTreeComparator;
	}

	public void setTreeView(javax.swing.JTree newTreeView) {
		this.treeView = newTreeView;
	}

	/*
	 * private void updateTreeView(Tree newTree, JTree treeView) throws
	 * Exception { treeView.setModel(new
	 * javax.swing.tree.DefaultTreeModel(newTree .getRoot()));
	 * treeView.repaint(); this.getFrame().pack(); }
	 */
	private void updateEquationChart(Tree newTree,
			EquationGraphPanel equationGraphPanel) {
		equationGraphPanel.setTree(newTree);
		equationGraphPanel.setTargetEquation(getTargetExpersion());
		equationGraphPanel.setTrainingData(genertateTrainingDataSet(-100,
				100));
		JFreeChart chart = getEquationGraphPanel().createChart(
				equationGraphPanel.createDataset());
		equationGraphPanel.setChart(chart);
		equationGraphPanel.repaint();
		this.getFrame().pack();
	}

	private void updateFitnessChart(int[] newDataset,
			double[] newTargetTreeValues, ArrayList<Tree> newTrees,
			PopulationFitnessPanel populationFitnesspanel) {
		populationFitnesspanel.setDataset(newDataset);
		populationFitnesspanel.setTrees(newTrees);
		populationFitnesspanel.setTargetTreeValues(newTargetTreeValues);
		JFreeChart chart = populationFitnesspanel
				.createChart(populationFitnesspanel.createDataset());
		populationFitnesspanel.setChart(chart);
		populationFitnesspanel.repaint();
		getFrame().pack();
	}
}
