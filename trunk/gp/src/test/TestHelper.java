package test;

import gp.Fitness;
import gp.FunctionalSet;
import gp.GeneticProgrammingException;
import gp.Node;
import gp.TerminalSet;
import gp.Tree;

import java.util.ArrayList;
import java.util.List;

import com.graphbuilder.math.Expression;
import com.graphbuilder.math.ExpressionTree;
import com.graphbuilder.math.VarMap;

/**
 * Helper class common test methods.
 * 
 */
public abstract class TestHelper {

	/**
	 * Method for populating a tree with nodes.
	 * 
	 * @param newTree
	 *            - Tree that needs nodes generated
	 * @param newParent
	 *            - Parent node to attach sibling (leaf) nodes onto.
	 * @param howDeepToMakeIt
	 *            - The total depth to make the tree.
	 * @throws GeneticProgrammingException
	 *             - if something goes wrong
	 * @return - populated tree
	 */
	protected static Tree generateNodes(final Tree newTree,
			final Node newParent, final int howDeepToMakeIt)
			throws GeneticProgrammingException {
		if (newParent.getLevel() == howDeepToMakeIt - 1) {
			final Node lOperand = new Node(newParent, getTerminalSet()
					.randomOperand(), Node.LEFT, Node.OPERAND);
			newTree.addNode(lOperand);
			final Node rOperand = new Node(newParent, getTerminalSet()
					.randomOperand(), Node.RIGHT, Node.OPERAND);
			newTree.addNode(rOperand);
		} else {
			final Node lOperator = new Node(newParent, getFunctionalSet()
					.randomOperator(), Node.LEFT, Node.OPERATOR);
			newTree.addNode(lOperator);
			generateNodes(newTree, lOperator, howDeepToMakeIt);
			final Node rOperator = new Node(newParent, getFunctionalSet()
					.randomOperator(), Node.RIGHT, Node.OPERATOR);
			newTree.addNode(rOperator);
			generateNodes(newTree, rOperator, howDeepToMakeIt);
		}
		return newTree;
	}

	/**
	 * This method creates a random population of trees using the terminal and
	 * functional sets.
	 * 
	 * @param newNumberOfTrees
	 *            - Size of binary tree population.
	 * 
	 * @param newHeight
	 *            - height of binary tree
	 * @param newDataset
	 *            - The training data
	 * @param targetTreeValues
	 *            - The target tree values
	 * @return - Returns a ArrayList of binary trees
	 * 
	 * @throws GeneticProgrammingException
	 *             - something went wrong
	 */
	public static List<Tree> populate(final int newNumberOfTrees,
			final int newHeight, final int[] newDataset,
			final double[] targetTreeValues) throws GeneticProgrammingException {
		final ArrayList<Tree> population = new ArrayList<Tree>();
		for (int y = 0; y < newNumberOfTrees; y++) {
			final Node rootNode = new Node(null, getFunctionalSet()
					.randomOperator(), null, Node.OPERATOR);
			final Tree tree = new Tree(rootNode, getTerminalSet(),
					getFunctionalSet());
			rootNode.setTree(tree);
			generateNodes(tree, rootNode, newHeight);

			final double fitness = Fitness.checkFitness(targetTreeValues,
					Fitness.calculateExpressionValues(tree, newDataset));
			tree.setFitness(fitness);
			population.add(tree);
		}

		return population;
	}

	/**
	 * Method for calculating the values of the training data applied against
	 * the target equation.
	 * 
	 * @param targetedExpresion
	 *            - target expression
	 * @param dataset
	 *            - training data
	 * @return returns a list of values.
	 */
	protected static double[] calculateTargetValues(
			final String targetedExpresion, final int[] dataset) {
		final int datasetSize = dataset.length;
		double[] targetTreeValues = new double[datasetSize];
		final Expression exp = ExpressionTree.parse(targetedExpresion);
		final VarMap varMap = new VarMap(false /* case sensitive */);
		for (int x = 0; x < datasetSize; x++) {
			varMap.setValue("x", dataset[x]);
			targetTreeValues[x] = exp.eval(varMap, null);
		}
		return targetTreeValues;
	}

	/**
	 * This method generates a set of values that are generated by the passed in
	 * equation.
	 * 
	 * @param newMax
	 *            - Minimum integer range
	 * @param newMin
	 *            - Maximum integer range
	 * @return - ArrayList of integers in range specified.
	 */
	protected static int[] genertateTrainingDataSet(final int newMin,
			final int newMax) {
		int[] values = new int[newMax - newMin];
		int temp = newMin;
		for (int x = 0; x < values.length; x++) {
			values[x] = temp++;
		}
		return values;
	}

	/**
	 * Helper method to create terminal set.
	 * 
	 * @return the terminal set
	 */
	protected static TerminalSet getTerminalSet() {
		final TerminalSet terminalSet = new TerminalSet();
		terminalSet.add("1");
		terminalSet.add("2");
		terminalSet.add("3");
		terminalSet.add("4");
		terminalSet.add("5");
		terminalSet.add("6");
		terminalSet.add("7");
		terminalSet.add("8");
		terminalSet.add("9");
		terminalSet.add("x");
		return terminalSet;
	}

	/**
	 * Helper method to create functional set.
	 * 
	 * @return the functional set
	 */
	protected static FunctionalSet getFunctionalSet() {
		final FunctionalSet functionalSet = new FunctionalSet();
		functionalSet.add("+");
		functionalSet.add("-");
		functionalSet.add("/");
		functionalSet.add("*");
		return functionalSet;
	}
}
